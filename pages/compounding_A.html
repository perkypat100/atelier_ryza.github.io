<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ライザのアトリエ 情報置き場 調合</title>
    <!-- DataTables CSS -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css">
    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- DataTables JS -->
    <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
    <!-- PapaParse JS (CSV parsing library) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.21.0/cytoscape.min.js"></script>
    <style>
        #cy {
            width: 100%;
            height: 500px;
            display: block;
        }
    </style>
</head>

<body>

    <h1>ライザのアトリエ 情報置き場 調合</h1>
    このページでは調合の情報を漏れなく記述する。

    <hr>

    <label for="graphSelect">Select Graph:</label>
    <select id="graphSelect">
        <option value="1">Graph 1</option>
        <option value="2">Graph 2</option>
    </select>

    <div id="cy"></div>

    <script>
        // Define a color map based on color names
        const colorMap = {
            "黄": "#B5A60A",
            "赤": "#D13A30",
            "青": "#2C5C7A",
            "緑": "#5A9A47"
        };

        // Function to create Cytoscape graph
        function createCytoscape(nodesData, edgesData) {
            var cy = cytoscape({
                container: document.getElementById('cy'), // HTML element ID
                elements: { nodes: nodesData, edges: edgesData },

                style: [
                    // Style for main nodes
                    {
                        selector: 'node',
                        style: {
                            'background-color': 'data(color)', // Use the color from the CSV data
                            'label': function (ele) {
                                return '材料: ' + ele.data('material') + '\n属性値: ' + ele.data('attribute_value');
                            },
                            'text-wrap': 'wrap',
                            'text-max-width': '80px',
                            'color': '#fff',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': '10px',
                            'shape': 'ellipse',
                            'width': '80px',
                            'height': '80px'
                        }
                    },

                    // Style for edges
                    {
                        selector: 'edge',
                        style: {
                            'width': 2,
                            'line-color': '#B2B2B2',
                            'target-arrow-color': '#B2B2B2',
                            'target-arrow-shape': 'triangle'
                        }
                    }
                ],

                layout: {
                    name: 'grid',
                    rows: 2
                }
            });
        }

        // Function to wrap Papa.parse in a promise
        function parseCSV(url) {
            return new Promise(function (resolve, reject) {
                Papa.parse(url, {
                    download: true,
                    header: true,
                    complete: function (results) {
                        resolve(results.data);
                    },
                    error: function (error) {
                        reject(error);
                    }
                });
            });
        }

        // Function to load CSV files and create the graph based on the selected レシピ名
        function loadCSV(graph_id) {
            let nodesData = [];
            let edgesData = [];

            // First load compounding_nodes.csv
            parseCSV('compounding_nodes.csv')
                .then(function (results) {
                    // Filter nodes by selected レシピ名 and map the data
                    nodesData = results.filter(function (row) {
                        return row['レシピ名'] === graph_id;
                    }).map(function (row) {
                        return {
                            data: {
                                id: row.id,
                                label: row['ラベル'],
                                color: colorMap[row['色']], // Map color name to color code
                                priority: row['優先度'], // Use the 優先度 column
                                material: row['材料'], // Use the 材料 column
                                attribute_value: row['属性値'] // Use the 属性値 column
                            }
                        };
                    });

                    // Then load compounding_edges.csv
                    return parseCSV('compounding_edges.csv');
                })
                .then(function (results) {
                    // Filter edges by selected レシピ名 and map the data
                    edgesData = results.filter(function (row) {
                        return row['レシピ名'] === graph_id;
                    }).map(function (row) {
                        return { data: { source: row.source, target: row.target } };
                    });

                    // Create the Cytoscape graph
                    createCytoscape(nodesData, edgesData);
                })
                .catch(function (error) {
                    console.error("Error loading CSV files:", error);
                });
        }

        // Load the CSV and create the graph based on selected レシピ名
        window.onload = function () {
            var graphSelect = document.getElementById('graphSelect');
            var selectedGraphId = graphSelect.value;

            // Load the graph based on the initial selected レシピ名
            loadCSV(selectedGraphId);

            // Change graph when a different レシピ名 is selected
            graphSelect.addEventListener('change', function () {
                selectedGraphId = this.value;
                loadCSV(selectedGraphId);
            });
        };
    </script>


    <script>
        // CSVファイルをAjaxで読み込んでパース
        function fetchAndDisplayCSV() {
            Papa.parse('item.csv', {
                download: true,
                header: true,
                skipEmptyLines: true, // 空行をスキップして末尾の改行に対応
                complete: function (results) {
                    var data = results.data;

                    var table = $('#itemTable').DataTable(); // DataTableの初期化

                    // CSVデータをテーブルに追加
                    data.forEach(function (row) {
                        if (Object.keys(row).length > 0) {
                            table.row.add([
                                row['アイテム名'],
                                row['Lv'],
                                row['スロット'],
                                row['適正道具'],
                                row['装備可能者'],
                                row['カテゴリ'],
                                row['属性'],
                                row['採取できる場所']
                            ]).draw(false);
                        }
                    });
                    table.draw();
                },
                error: function (error) {
                    console.error('CSV読み込み中にエラーが発生しました:', error);
                }
            });
        }

        $(document).ready(function () {
            $.fn.dataTable.ext.search.push(
                function (settings, data, dataIndex) {
                    var allColumnsValid = true;

                    // 1. ドロップダウン検索の処理
                    function checkDropdown(columnIndex, filterId, allowAllMatch, partialMatch) {
                        var filterValue = $(filterId).val();
                        var columnValue = data[columnIndex] || "";

                        // 「装備可能者」列で"全員"が選択されている場合はどのフィルタにもマッチさせる
                        if (allowAllMatch && columnValue === "全員") {
                            return true;
                        }

                        // 部分一致を許可する場合
                        if (partialMatch && filterValue && filterValue !== "") {
                            return columnValue.includes(filterValue); // 部分一致チェック
                        }

                        // 完全一致チェック
                        if (filterValue && filterValue !== "" && filterValue !== columnValue) {
                            return false; // 一致しない場合は無効
                        }

                        return true;
                    }

                    // 「装備可能者」列にのみ「全員」に関する処理を適用
                    allColumnsValid = allColumnsValid && checkDropdown(3, '#itemFilter', false, true); // 「装備可能者」列のフィルタ
                    allColumnsValid = allColumnsValid && checkDropdown(4, '#charaFilter', true, false); // 「装備可能者」列のフィルタ
                    allColumnsValid = allColumnsValid && checkDropdown(5, '#categoryFilter', false, false); // カテゴリフィルタ
                    allColumnsValid = allColumnsValid && checkDropdown(6, '#elementFilter', false, false); // 属性フィルタ
                    allColumnsValid = allColumnsValid && checkDropdown(7, '#spotFilter', false, true);


                    return allColumnsValid;
                }
            );

            // DataTablesの初期化と列ごとの検索機能を追加
            var table = $('#itemTable').DataTable({
                initComplete: function () {
                    this.api().columns().every(function () {
                        var that = this;

                        // 各列にある検索ボックスのイベントを設定
                        $('input', this.header()).on('keyup change', function () {
                            if (that.search() !== this.value) {
                                that.search(this.value).draw();
                            }
                        });
                    });
                }
            });

            // 各ドロップダウンのイベント
            $('#charaFilter, #categoryFilter, #elementFilter').on('change', function () {
                table.draw(); // ドロップダウンの選択変更時にテーブルを再描画
            });

            // CSVデータの読み込みと表示を行う
            fetchAndDisplayCSV();
        });
    </script>

    <div id="footer"></div>
    <script>
        fetch('../include/footer.html')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.text();
            })
            .then(data => {
                document.getElementById('footer').innerHTML = data;
            })
            .catch(error => {
                console.error('There was a problem with the fetch operation:', error);
            });
    </script>

</body>

</html>